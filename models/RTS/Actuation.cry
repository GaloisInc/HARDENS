module RTS::Actuation where

import RTS::Instrumentation

type Trips = [3][8] // [8] is more convenient
type Input = [4]Trips

type NDevices = 2
type Device = [lg2 NDevices]
D0 = 0
D1 = 1

type ActuationLogic =
  { vote_actuate: Voting
  , manual_actuate: [2] // RFP does not suggest this is protected by a mode
  }

type Voting = [2]
type ActuatorOutput = [2]

// This controls an actuator,
// the input is the output signal
// from *two* logic units
ActuateDevice: [2] -> Bit
ActuateDevice vs = (vs @ 0) || (vs @ 1)

Is_Actuated: Device -> ActuationLogic -> Bit
Is_Actuated d state = actuators @ d
  where
    actuators = state.manual_actuate || state.vote_actuate

Is_ManualActuated: Device -> ActuationLogic -> Bit
Is_ManualActuated d state = state.manual_actuate @ d

Is_AutoActuated: Device -> ActuationLogic -> Bit
Is_AutoActuated d state = state.vote_actuate @ d

Set_Manual_Actuation: Device -> Bit -> ActuationLogic -> ActuationLogic
Set_Manual_Actuation d val a = { a | manual_actuate = update a.manual_actuate d val }

Voting_Step : Input -> Voting -> Voting
Voting_Step inp old_votes = [d0, d1]
  where
    // Should use constants for the below, but that
    // is problematic for crymp
    d0 = Vote 0 inp || Vote 1 inp || old_votes @ (0 : Device)
    d1 = Vote 2 inp || old_votes @ (1 : Device)

Vote: Channel -> Input -> Bit
Vote ch inp = Coincidence_2_4 [ (i @ ch) == 1 | i <- inp ]

Coincidence_2_4 : [4] -> Bit
Coincidence_2_4 x = (x != 0) && (x != 1) && (x != 2) && (x != 4) && (x != 8)

Check_Actuate:
  Input ->
  ActuationLogic ->
  ActuationLogic
Check_Actuate input state = voted
  where
    voted : ActuationLogic
    voted = {state| vote_actuate = Voting_Step input state.vote_actuate}

private

  count : {n} (fin n) =>  [n] -> Integer
  count bs = sum [ if b then 1 else 0 | b <- bs ]

  /** @requirements
        ACTUATION_LOGIC_VOTE_TEMPERATURE
  */
  property actuation_logic_vote_temperature (inp: Input) =
    (count [(i @ T) == 1 | i <- inp] >= 2) == Vote T inp

  /** @requirements
        ACTUATION_LOGIC_VOTE_PRESSURE
  */
  property actuation_logic_vote_pressure (inp: Input) =
    (count [(i @ P) == 1 | i <- inp] >= 2) == Vote P inp

  /** @requirements
        ACTUATION_LOGIC_VOTE_SATURATION
  */
  property actuation_logic_vote_saturation (inp: Input) =
    (count [(i @ S) == 1 | i <- inp] >= 2) == Vote S inp

  /** @requirements
        ACTUATION_LOGIC_DEVICE_0
        ACTUATION_LOGIC_VOTE_DEVICE_0
        ACTUATION_LOGIC_VOTE_MANUAL_DEVICE_0
  */
  property actuation_logic_device_0 (inp: Input) (act: ActuationLogic) =
       act.manual_actuate @ D0
    \/ Is_AutoActuated D0 act
    \/ Vote T inp
    \/ Vote P inp
    == /* ---------------- */
    Is_Actuated D0 act'
    where act' = Check_Actuate inp act

  /** @requirements
        ACTUATION_LOGIC_DEVICE_1
        ACTUATION_LOGIC_VOTE_DEVICE_1
        ACTUATION_LOGIC_VOTE_MANUAL_DEVICE_1
  */
  property actuation_logic_device_1 (inp: Input) (act: ActuationLogic) =
       act.manual_actuate @ 1
    \/ Is_AutoActuated D1 act
    \/ Vote S inp
    == /* ---------------- */
    Is_Actuated D1 act'
    where act' = Check_Actuate inp act

  /** @requirements
         ACTUATION_LOGIC_MANUAL_DEVICE_0
  */
  property actuation_logic_manual_device_0 (v: Bit) (act: ActuationLogic) =
    Is_Actuated D0 act0 == v \/ Is_AutoActuated D0 act
    where act0 = Set_Manual_Actuation D0 v act

  /** @requirements
         ACTUATION_LOGIC_MANUAL_DEVICE_1
  */
  property actuation_logic_manual_device_1 (v: Bit) (act: ActuationLogic) =
    Is_Actuated D1 act' == v \/ Is_AutoActuated D1 act
    where act' = Set_Manual_Actuation D1 v act

  property actuation_logic d act0 act1 =
    ActuateDevice [Is_Actuated d act0, Is_Actuated d act1] ==
    (Is_Actuated d act0 \/ Is_Actuated d act1)
