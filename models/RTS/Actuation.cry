module RTS::Actuation where

import RTS::Instrumentation

type Input = [4][3]
type D0    = 0
type D1    = 1

newtype ActuationLogic =
  { vote_actuate: [2]Voting
  , manual_actuate: [2]
  }

type Voting = [2]
type ActuatorOutput = [2]

Is_Actuated: {d} (d <= 1) => ActuationLogic -> Bit
Is_Actuated state = actuators @ `d
  where
    actuators = state.manual_actuate || (state.vote_actuate @ 0) || (state.vote_actuate @ 1)

Is_ManualActuated: {d} (d <= 1) => ActuationLogic -> Bit
Is_ManualActuated state = state.manual_actuate @ `d

Is_AutoActuated: {d} (d <= 1) => ActuationLogic -> Bit
Is_AutoActuated state = actuators @ `d
  where
    actuators = (state.vote_actuate @ 0) || (state.vote_actuate @ 1)

Set_Manual_Actuation: [2] -> ActuationLogic -> ActuationLogic
Set_Manual_Actuation val a = { a | manual_actuate = val }

Voting_Step:
  Input /* Trip signals */ ->
  Voting ->
  Voting
Voting_Step input state0 = voting_state
  where
    voting_state =
      ApplyVote`{1} votes_s
        (ApplyVote`{0} (votes_t || votes_p) state0)

    // Collect Votes
    votes_t = coincidence_2_4 [ i @ `T | i <- input ]
    votes_p = coincidence_2_4 [ i @ `P | i <- input ]
    votes_s = coincidence_2_4 [ i @ `S | i <- input ]

    ApplyVote: {d} (d <= 1) => Bit -> Voting -> Voting
    ApplyVote vote st = update st `d vote

    // 2-out-of-four
    coincidence_2_4 : [4] -> Bit
    coincidence_2_4 x = (x != 0) && (x != 1) && (x != 2) && (x != 4) && (x != 8)

Check_Actuate:
  Input ->
  ActuationLogic ->
  ActuationLogic
Check_Actuate input state = voted
  where
    voted : ActuationLogic
    voted = {state| vote_actuate = [ Voting_Step input s | s <- state.vote_actuate ]}

private

  count : {n} (fin n) =>  [n] -> Integer
  count bs = sum [ if b then 1 else 0 | b <- bs ]

  property voting_correct_device_0 (inp: Input) (act: ActuationLogic) =
       act.manual_actuate @ `D0
    \/ count [ i @ `T | i <- inp ] >= 2 \/ count [ i @ `P | i <- inp ] >= 2
    == /* ---------------- */
    Is_Actuated`{D0} act'
    where act' = Check_Actuate inp act

  property voting_correct_device_1 (inp: Input) (act: ActuationLogic) =
    act.manual_actuate @ 1 \/ count [ i @ `S | i <- inp ] >= 2
    == /* ---------------- */
    Is_Actuated`{D1} act'
    where act' = Check_Actuate inp act

  property set_manual_correct_0 (vals: [2]) (act: ActuationLogic) =
    Is_Actuated`{D0} act' == (vals @ `D0) \/ Is_AutoActuated`{D0} act
    where act' = Set_Manual_Actuation vals act

  property set_manual_correct_1 (vals: [2]) (act: ActuationLogic) =
    Is_Actuated`{D1} act' == (vals @ `D1) \/ Is_AutoActuated`{D1} act
    where act' = Set_Manual_Actuation vals act
