/* This is the core logic of the HARDENS RTS system.

   The controller loop:
    - Reads and applies any (simultaneously supplied) UI commands
    - Drives the intrumentation units one step
    - Drives the actuation logic one step
    - Updates the UI output (display)

*/
module RTS where

import RTS::Instrumentation
import RTS::Instrumentation as Instrumentation
import RTS::Actuation
import RTS::Actuation as Actuation
import RTS::Utils

type EventType = [2]
// Event Type Values
EVENT_MAINTENANCE, EVENT_TRIP_MODE, EVENT_SETPOINT, EVENT_ACTUATE : EventType
EVENT_MAINTENANCE = 0
EVENT_TRIP_MODE = 1
EVENT_SETPOINT = 2
EVENT_ACTUATE = 3

// Union of all possible events
type Event =
  { event: [2] // The event tag
  , ch: [2] // Which channel
  , dev: [1] // Which device
  , unit: [2] // Which Instrumentation unit
  , setpoint: [32]
  , mode: Instrumentation::Mode
  , on_off: Bit
  }

type UI =
  { instrumentation_values: [4][NChannels][32]
  , instrumentation_bypass: [4][NChannels]
  , instrumentation_trip: [4][NChannels]
  }

type CoreFSM =
  { ui: UI
  , self_test: Bit // Are we running an end-to-end test?
  , self_test_instrs: [2][2] // Which instrumentation units are we poking?
  , self_test_channel: Channel // Which channel are we poking?
  , self_test_vote: [1] // Which voting unit are we observing?
  , self_test_dev: [1] // Which actuator are we observing?
  , self_test_expect: Bit
  , self_test_timer: [32]
  }

type RTS =
  { core: CoreFSM,
    instr: [4]Instrumentation,
    act: [2]ActuationLogic,
    devices: [2],
    error_detected: Bit

  , result: [2]
  }

MaskTripFrom: {n, idx} (fin n, Integral idx, Literal 0 idx) =>
  (idx -> Channel -> Bit) -> [n]Trips -> [n]Trips
MaskTripFrom p trips =
  [ [ if p j ch then 0 else ch_trip | ch_trip <- trip | ch <- [0..2] ]
  | trip <- trips
  | j <- [0...]
  ]


Sense_Actuate: [4]Instrumentation::Input -> [4]Instrumentation::Command -> [2]Actuation::Command -> RTS -> RTS
Sense_Actuate inputs icmds acmds rts =
  { rts | result = devices_test,
          instr = instrumentation',
          act = actuation_logic',
          devices = devices',
          error_detected = rts.core.self_test && test_fail }
  where
    // The two instrumentation units under test
    i0 = rts.core.self_test_instrs @ 0
    i1 = rts.core.self_test_instrs @ 1

    // Each instrumentation unit runs
    instrumentation'    = [ Instrumentation::Step input cmd i | i <- rts.instr | input <- inputs | cmd <- icmds ]
    output_trips        = [ instr.output_trip | instr <- instrumentation' ]

    // Mask trips from the instrs under test at the channel under test. This is passed
    // to the voting components _not_ under test (so that we do not count any test-generated trips)
    output_trips_masked = MaskTripFrom (\i ch -> elem i [i0, i1] && (ch == rts.core.self_test_channel)) output_trips
    output_trips_test   = MaskTripFrom (\i ch -> ~ (elem i [i0, i1] && (ch == rts.core.self_test_channel))) output_trips

    // Now run the voting logic
    actuation_logic' : [2]ActuationLogic
    actuation_logic' = [ Actuation::Step (Select_trips l) acmd logic | logic <- rts.act | acmd <- acmds | l <- [0..1] ]

    Select_trips l = if rts.core.self_test then
                        (if l == rts.core.self_test_vote then output_trips_test else output_trips_masked)
                     else
                        output_trips

    // This is the output to the devices
    devices' : [2]
    devices' = [ Actuation::Actuate_Device [ Actuation::Is_Actuated d logic | logic <- actuation_logic' ] | d <- [0..1] ]

    // Mask out the output of the voting unit we are *not* testing, and then use *this* value
    // for testing device actuation
    logic_test = [[ if (rts.core.self_test_vote == l) && (rts.core.self_test_dev == d) then
                          Actuation::Is_Actuated d logic
                      else
                          0
                   | logic <- actuation_logic' | l <- [0..1] ] | d <- [0..1]]

    devices_test : [2]
    devices_test = [Actuation::Actuate_Device logic | logic <- logic_test ]
    test_fail    = rts.core.self_test_expect != (devices_test @ rts.core.self_test_dev)


Test_Instrumentation : [2] -> RTS -> RTS
Test_Instrumentation i rts = {rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test: ([8],[2][32],Channel) -> Bit
    Run_test (trip,vals,ch) = (rts.instr @ i)
                         >>>> Set_Maintenance True
                         >>>> Set_Mode ch Operate
                         >>>> Set_Setpoint ch 10
                         >>>> Set_Maintenance False
                         >>>> (\in -> Instrumentation::Step vals Instrumentation::NoCommand in)
                         >>>> (\in -> (trip == (in.output_trip @ ch)))

    // For example...
    tests: [_]([8],[2][32],Channel)
    tests = [ (1, [h,l], T) | h <- high, l <- low ] #
            [ (0, [l,h], T) | h <- high, l <- low ] #
            [ (1, [l,h], P) | h <- high, l <- low ] #
            [ (0, [h,l], P) | h <- high, l <- low ] #
            [ (1, [t,p], S) | t <- [10,20,30], p <- [4,5,6] ] #
            [ (0, [t,p], S) | t <- [60,70,80], p <- [3,4,5] ]

    high: [_][32]
    high = [11, 12, 20]

    low: [_][32]
    low = [0, 9, 10]

Test_Voting: [1] -> RTS -> RTS
Test_Voting l rts = { rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test (on,d,trips) = (rts.act @ l)
                       >>>> Actuation::Set_Manual_Actuation d False
                       >>>> Actuation::Step trips Actuation::NoCommand
                       >>>> \a -> Is_Actuated d a == on

    tests : [_](Bit, [1], Actuation::Input)
    tests = [ (should_trip d [t0,t1,t2,t3], d, [t0,t1,t2,t3]) | d <- [0,1], t0 <- all_trips, t1 <- all_trips, t2 <- all_trips, t3 <- all_trips ]

    should_trip d ts =
      if d == D0 then
           (sum [ t @ T | t <- ts ] >= 2)
        || (sum [ t @ P | t <- ts ] >= 2)
      else
           sum [ t @ S | t <- ts ] >= 2

    all_trips: [8]Trips
    all_trips = [ [a,b,c] | a <- [0,1], b <- [0,1], c <- [0,1] ]

Test_Actuation: RTS -> RTS
Test_Actuation rts = { rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test (on,votes) = on == Actuate_Device votes
    tests : [_](Bit, [2])
    tests = [ (v1 || v2, [v1, v2]) | v1 <- [0, 1], v2 <- [0, 1] ]

Update_UI: [4]Instrumentation -> [2]ActuationLogic -> CoreFSM -> CoreFSM
Update_UI instrs actuator rts0 =
  rts0 >>>> get_values >>>> get_bypass >>>> get_trip
  where
    get_values rts = {rts| ui = {rts.ui| instrumentation_values = [ Get_Reading i | i <- instrs ]}}
    get_bypass rts = {rts| ui = {rts.ui| instrumentation_bypass = [ [In_Mode T Bypass i, In_Mode P Bypass i, In_Mode S Bypass i] | i <- instrs ]}}
    get_trip   rts = {rts| ui = {rts.ui| instrumentation_trip = [ [Is_Tripped T i, Is_Tripped P i, Is_Tripped S i] | i <- instrs ]}}

Run_Event: Event -> RTS -> RTS
Run_Event e rts =
  if e.event == EVENT_MAINTENANCE then
    {rts| instr = update rts.instr (e.unit) (Set_Maintenance e.on_off (rts.instr @ e.unit))}
  else if (e.event == EVENT_TRIP_MODE) && (ch < `NChannels) && (e.mode < `NModes) then
    {rts| instr = update rts.instr (e.unit) (Set_Mode ch e.mode (rts.instr @ e.unit))}
  else if (e.event == EVENT_SETPOINT) && (ch < `NChannels) then
    {rts| instr = update rts.instr (e.unit) (Set_Setpoint ch e.setpoint (rts.instr @ e.unit))}
  else if (e.event == EVENT_ACTUATE) then
    {rts| act = [Set_Manual_Actuation dev e.on_off a | a <- rts.act]}
  else rts
  where
    ch : Channel
    ch = e.ch
    dev : Device
    dev = e.dev

private
    I : ([4]Instrumentation -> [4]Instrumentation) -> RTS -> RTS
    I f rts = {rts|instr = f rts.instr}
    A : ([2]ActuationLogic -> [2]ActuationLogic) -> RTS -> RTS
    A f rts = {rts|act = f rts.act}
    C : (CoreFSM -> CoreFSM) -> RTS -> RTS
    C f rts = {rts|core = f rts.core}


    /** @requirements
          CORE_UI_INSTRUMENTATION
    */
    property core_ui_instrumentation (rts: RTS) (i: [2]) =
           ((core'.ui.instrumentation_values @ i)     == Get_Reading (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ T) == In_Mode T Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ P) == In_Mode P Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ S) == In_Mode S Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ T)   == Is_Tripped T (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ P)   == Is_Tripped P (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ S)   == Is_Tripped S (rts.instr @ i))
      where
        core' = Update_UI rts.instr rts.act rts.core

    property sense_to_actuate_0 rts (sensors : [4][2][32]) cmds acmds =
        ~rts.core.self_test ==> (
           sum [ if Is_Tripped T i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ sum [ if Is_Tripped P i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated D0 a | a <- rts.act ]
        \/ or [ Is_ManualActuated D0 a | a <- rts'.act ]
        \/ or [ Is_Actuated D0 a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated D0 a | a <- rts'.act ]
      )
      where
        rts' = rts >>>> Sense_Actuate sensors cmds acmds

    property sense_to_actuate_1 rts (sensors : [4][2][32]) cmds acmds =
        ~rts.core.self_test ==> (
           sum [ if Is_Tripped S i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated D1 a | a <- rts.act ]
        \/ or [ Is_ManualActuated D1 a | a <- rts'.act ]
        \/ or [ Is_Actuated D1 a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated D1 a | a <- rts'.act ]
        )
      where
        rts' = rts >>>> Sense_Actuate sensors cmds acmds

    property end_to_end_test rts i1 i2 (ch : [2]) vote sensors =
       ( ~rts.error_detected
         /\ (i1 != i2)
         /\ and [ (a.manual_actuate == 0) && (a.vote_actuate == 0) | a <- rts.act ]
         /\ (ch < 3 /* not provable if ch == S */)) /\ (ch != S) // Add this to make it provable
      /* ------------------------------------------*/ ==>
         ~rts'.error_detected
     where
       rts' = RunEndToEnd rts i1 i2 ch vote sensors

    property end_to_end_test_non_interference rts (sensors: [4][2][32]) (ch : [2]) =
      (~ rts.error_detected
       // Start in a state where we haven't actuated
       /\ and [ (a.manual_actuate == 0) && (a.vote_actuate == 0) | a <- rts.act ]
       /\ ch < 3
       // Check if enough of the non-tested instrumentation (which may be all of them!) thinks we should
       // actuate
       /\ sum [ if (~rts.core.self_test || ~elem i [i1,i2]) && ChShouldTrip ch vs instr then 1 else 0
              | vs <- sensors
              | instr <- rts.instr
              | i <- [0...]
              ] >= 2
      ) /* ------------------------------------------------------------- */ ==>
      or [ Is_Actuated (if ch == S then D1 else D0) a | a <- rts'.act ]
      where
        i1 = rts.core.self_test_instrs@0
        i2 = rts.core.self_test_instrs@1
        rts' = rts >>>> Sense_Actuate sensors (repeat Instrumentation::NoCommand) (repeat Actuation::NoCommand)

    RunEndToEnd rts i1 i2 ch vote sensors = rts'
      where
       mkTestCore : [4]Instrumentation -> CoreFSM
       mkTestCore instrs = {rts.core| self_test = True,
                            self_test_instrs = [i1, i2],
                            self_test_channel = ch,
                            self_test_vote = vote,
                            self_test_dev = dev,
                            self_test_expect = ShouldTrip ch sensors instrs [i1,i2] }
       dev = if (ch == T) || (ch == P) then D0 else D1
       rts' = rts
         >>>> I (\instrs -> [ if (i == i1) || (i == i2) then Set_Maintenance True instr else instr | instr <- instrs | i <- [0..3] ])
         >>>> I (\instrs -> [ if (i == i1) || (i == i2) then Set_Mode ch Operate instr else instr | instr <- instrs | i <- [0..3] ])
         >>>> (\r -> {r | core = (mkTestCore r.instr) })
         >>>> Sense_Actuate sensors cmds acmds
       cmds = repeat Instrumentation::NoCommand
       acmds = repeat Actuation::NoCommand

    ShouldTrip: Channel -> [4][2][32] -> [4]Instrumentation -> [2][2] -> Bit
    ShouldTrip ch sensors instrumentation test_instrs =
       numBits [ ChShouldTrip ch vs instr
               | vs <- sensors @@ test_instrs | instr <- instrumentation @@ test_instrs ] >= 2

    ChShouldTrip ch vs instr =
      if In_Mode ch Operate instr then
        if (ch == T) || (ch == P)
        then (instr.setpoints @ ch) < (vs @ ch)
        else (instr.setpoints @ ch) > Saturation (vs @ T) (vs @ P)
      else
        In_Mode ch Manual instr

    property Test_Instrumentation_OK i rts =
      ~(rts.error_detected) ==>
      ~ ((Test_Instrumentation i rts).error_detected)

    property Test_Voting_OK l rts =
      (~rts.error_detected && and [ a.vote_actuate == 0 | a <- rts.act ]) ==>
      ~ ((Test_Voting l rts).error_detected)

    property Test_Actuation_OK rts =
      ~ (rts.error_detected) ==>
      ~ ((Test_Actuation rts).error_detected)
