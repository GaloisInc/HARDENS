/* This is the core logic of the HARDENS RTS system.

   The controller loop:
    - Reads and applies any (simultaneously supplied) UI commands
    - Drives the intrumentation units one step
    - Drives the actuation logic one step
    - Updates the UI output (display)

*/
module RTS where

import RTS::Instrumentation
import RTS::Actuation
import RTS::Utils

newtype UI =
  { instrumentation_values: [4][3][32]
  , instrumentation_bypass: [4][2]
  , instrumentation_trip: [4][3]
  }

newtype CoreFSM =
  { ui: UI
  // Instrumentation output events
  , out_maintenance: [4]
  , out_bypass: [4][2]
  , out_setpoints: [4][3][32]
  , out_force_trip: [4][3]
  // Actuation output events
  , out_manual_actuate: [2]
  }

Update_UI: [4]Instrumentation -> ActuationLogic -> CoreFSM -> CoreFSM
Update_UI instrs actuator rts0 =
  rts0 >>>> get_values >>>> get_bypass >>>> get_trip
  where
    get_values rts = {rts| ui = {rts.ui| instrumentation_values = [ Get_Reading i | i <- instrs ]}}
    get_bypass rts = {rts| ui = {rts.ui| instrumentation_bypass = [ [In_Bypass`{T} i, In_Bypass`{P} i] | i <- instrs ]}}
    get_trip   rts = {rts| ui = {rts.ui| instrumentation_trip = [ [Is_Tripped`{T} i, Is_Tripped`{P} i, Is_Tripped`{S} i] | i <- instrs ]}}

Handle_Set_Maintenance: [2] -> Bit -> CoreFSM -> CoreFSM
Handle_Set_Maintenance div val rts =
  {rts| out_maintenance = update rts.out_maintenance div val}

newtype RTS = { core: CoreFSM, instr: [4]Instrumentation, act: ActuationLogic }

private
    I : ([4]Instrumentation -> [4]Instrumentation) -> RTS -> RTS
    I f rts = {rts|instr = f rts.instr}
    A : (ActuationLogic -> ActuationLogic) -> RTS -> RTS
    A f rts = {rts|act = f rts.act}
    C : (CoreFSM -> CoreFSM) -> RTS -> RTS
    C f rts = {rts|core = f rts.core}

    property sense_to_actuate_0 rts (sensors : [4][2][32]) =
           sum [ if Is_Tripped`{T} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ sum [ if Is_Tripped`{P} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ Is_ManualActuated`{D0} rts.act
        /* --------------------- */ ==
        Is_Actuated`{D0} rts'.act
      where
        rts' = rts
          >>>> I (\instrs -> [ Read_Sensors (sensors @ i) instr | instr <- instrs | i <- [0..3] ])
          >>>> (\rts1 -> {rts1| act = Check_Actuate (map Get_Tripped rts1.instr) rts1.act})

    property sense_to_actuate_1 rts (sensors : [4][2][32]) =
           sum [ if Is_Tripped`{S} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ Is_ManualActuated`{D1} rts.act
        /* --------------------- */ ==
        Is_Actuated`{D1} rts'.act
      where
        rts' = rts
          >>>> I (\instrs -> [ Read_Sensors (sensors @ i) instr | instr <- instrs | i <- [0..3] ])
          >>>> (\rts1 -> {rts1| act = Check_Actuate (map Get_Tripped rts1.instr) rts1.act})
