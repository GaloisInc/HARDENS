/* This is the core logic of the HARDENS RTS system.

   The controller loop:
    - Reads and applies any (simultaneously supplied) UI commands
    - Drives the intrumentation units one step
    - Drives the actuation logic one step
    - Updates the UI output (display)

*/
module RTS where

import RTS::Instrumentation
import RTS::Actuation
import RTS::Utils

MAINTENANCE, TRIP_MODE, SETPOINT, ACTUATE : [2]
MAINTENANCE = 0
TRIP_MODE = 1
SETPOINT = 2
ACTUATE = 3

newtype Event (ch : #) (dev : #) =
  { event: [2]
    // Instrumentation output event arguments
  , division: [2]
  , setpoint: [32]
  , mode: [2]
  , on_off: Bit
  }

newtype UI =
  { instrumentation_values: [4][3][32]
  , instrumentation_bypass: [4][3]
  , instrumentation_trip: [4][3]
  }

newtype CoreFSM =
  { ui: UI
  }

Update_UI: [4]Instrumentation -> [2]ActuationLogic -> CoreFSM -> CoreFSM
Update_UI instrs actuator rts0 =
  rts0 >>>> get_values >>>> get_bypass >>>> get_trip
  where
    get_values rts = {rts| ui = {rts.ui| instrumentation_values = [ Get_Reading i | i <- instrs ]}}
    get_bypass rts = {rts| ui = {rts.ui| instrumentation_bypass = [ [In_Trip_Mode`{T} `Bypass i, In_Trip_Mode`{P} `Bypass i, In_Trip_Mode`{S} `Bypass i] | i <- instrs ]}}
    get_trip   rts = {rts| ui = {rts.ui| instrumentation_trip = [ [Is_Tripped`{T} i, Is_Tripped`{P} i, Is_Tripped`{S} i] | i <- instrs ]}}

newtype RTS = { core: CoreFSM, instr: [4]Instrumentation, act: [2]ActuationLogic }

Run_Event: {ch, dev} (ch <= 2, dev <= 1) => Event ch dev -> RTS -> RTS
Run_Event e rts =
  if e.event == MAINTENANCE then
    {rts| instr = update rts.instr (e.division) (Set_Maintenance e.on_off (rts.instr @ e.division))}
  else if (e.event == TRIP_MODE) && (`ch <= 1) && (e.mode <= 2) then
    {rts| instr = update rts.instr (e.division) (Set_Trip_Mode`{Ch ch} e.mode (rts.instr @ e.division))}
  else if (e.event == SETPOINT) then
    {rts| instr = update rts.instr (e.division) (Set_Setpoint`{ch} e.setpoint (rts.instr @ e.division))}
  else if (e.event == ACTUATE) then
    {rts| act = [Set_Manual_Actuation`{dev} e.on_off a | a <- rts.act]}
  else rts
  where
    type Ch c = c % 2

private
    I : ([4]Instrumentation -> [4]Instrumentation) -> RTS -> RTS
    I f rts = {rts|instr = f rts.instr}
    A : ([2]ActuationLogic -> [2]ActuationLogic) -> RTS -> RTS
    A f rts = {rts|act = f rts.act}
    C : (CoreFSM -> CoreFSM) -> RTS -> RTS
    C f rts = {rts|core = f rts.core}


    /** @requirements
          CORE_UI_INSTRUMENTATION
    */
    property core_ui_instrumentation (rts: RTS) (i: [2]) =
           ((core'.ui.instrumentation_values @ i)      == Get_Reading (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ `T) == In_Trip_Mode`{T} `Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ `P) == In_Trip_Mode`{P} `Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ `S) == In_Trip_Mode`{S} `Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ `T)   == Is_Tripped`{T} (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ `P)   == Is_Tripped`{P} (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ `S)   == Is_Tripped`{S} (rts.instr @ i))
      where
        core' = Update_UI rts.instr rts.act rts.core

    property sense_to_actuate_0 rts (sensors : [4][2][32]) =
           sum [ if Is_Tripped`{T} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ sum [ if Is_Tripped`{P} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated`{D0} a | a <- rts.act ]
        \/ or [ Is_Actuated`{D0} a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated`{D0} a | a <- rts'.act ]
      where
        rts' = rts
          >>>> I (\instrs -> [ Update_Tripped (sensors @ i) instr | instr <- instrs | i <- [0..3] ])
          >>>> (\rts1 -> {rts1| act = map (Check_Actuate (map Get_Tripped rts1.instr)) rts1.act})

    property sense_to_actuate_1 rts (sensors : [4][2][32]) =
           sum [ if Is_Tripped`{S} i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated`{D1} a | a <- rts.act ]
        \/ or [ Is_Actuated`{D1} a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated`{D1} a | a <- rts'.act ]
      where
        rts' = rts
          >>>> I (\instrs -> [ Update_Tripped (sensors @ i) instr | instr <- instrs | i <- [0..3] ])
          >>>> (\rts1 -> {rts1| act = map (Check_Actuate (map Get_Tripped rts1.instr)) rts1.act})
