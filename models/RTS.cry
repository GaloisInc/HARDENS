/* This is the core logic of the HARDENS RTS system.

   The controller loop:
    - Reads and applies any (simultaneously supplied) UI commands
    - Drives the intrumentation units one step
    - Drives the actuation logic one step
    - Updates the UI output (display)

*/
module RTS where

import RTS::Instrumentation
import RTS::Instrumentation as Instrumentation
import RTS::Actuation
import RTS::Actuation as Actuation
import RTS::Utils

type EventType = [2]
// Event Type Values
EVENT_MAINTENANCE, EVENT_TRIP_MODE, EVENT_SETPOINT, EVENT_ACTUATE : EventType
EVENT_MAINTENANCE = 0
EVENT_TRIP_MODE = 1
EVENT_SETPOINT = 2
EVENT_ACTUATE = 3

// Union of all possible events
type Event =
  { event: [2] // The event tag
  , ch: [2] // Which channel
  , dev: [1] // Which device
  , unit: [2] // Which Instrumentation unit
  , setpoint: [32]
  , mode: Instrumentation::Mode
  , on_off: Bit
  }

type UI =
  { instrumentation_values: [4][NChannels][32]
  , instrumentation_bypass: [4][NChannels]
  , instrumentation_trip: [4][NChannels]
  }

type CoreFSM =
  { ui: UI
  , self_test: Bit // Are we running an end-to-end test?
  , self_test_instrs: [2][2] // Which instrumentation units are we poking?
  , self_test_channel: Channel // Which channel are we poking?
  , self_test_vote: [1] // Which voting unit are we observing?
  , self_test_dev: [1] // Which actuator are we observing?
  , self_test_expect: Bit
  , self_test_timer: [32]
  }

type RTS =
  { core: CoreFSM,
    instr: [4]Instrumentation,
    act: [2]ActuationLogic,
    devices: [2],
    error_detected: Bit

  , result: [2]
  }

Sense_Actuate: [4]Instrumentation::Input -> [4]Instrumentation::Command -> RTS -> RTS
Sense_Actuate inputs cmds rts =
  { rts | result = devices_test, instr = instrumentation', act = actuation_logic', devices = devices', error_detected = rts.core.self_test && test_fail }
  where
    i0 = rts.core.self_test_instrs @ 0
    i1 = rts.core.self_test_instrs @ 1
    instrumentation'    = [ Instrumentation::Step input cmd i | i <- rts.instr | input <- inputs | cmd <- cmds ]
    output_trips        = [ instr.output_trip | instr <- instrumentation' ]

    // Mask trips from the instrs under test at the channel under test:
    output_trips_masked = [ if (i == i0) || (i == i1) then
                              update trips rts.core.self_test_channel 0
                            else trips
                            | trips <- output_trips | i <- [0..3]
                          ]
    output_trips_test = [ if (i == i0) || (i == i1) then
                              [ if ch == rts.core.self_test_channel then trip else 0 | ch <- [0..2] | trip <- trips ]
                          else
                              repeat 0
                        | trips <- output_trips | i <- [0..3]
                        ]

    actuation_logic' : [2]ActuationLogic
    actuation_logic' = [ Actuation::Step (Select_trips l) logic
                       | logic <- rts.act
                       | l <- [0..1]
                       ]

    logic_masked = [[ if (rts.core.self_test_vote == l) && (rts.core.self_test_dev == d) then
                          Actuation::Is_Actuated d logic
                      else
                          0
                   | logic <- actuation_logic' | l <- [0..1] ] | d <- [0..1]]

    Select_trips l = if rts.core.self_test then
                        if l == rts.core.self_test_vote then output_trips_test else output_trips_masked
                     else
                        output_trips
    devices' : [2]
    devices' = [ Actuation::Actuate_Device [ Actuation::Is_Actuated d logic | logic <- actuation_logic' ] | d <- [0..1] ]

    devices_test : [2]
    devices_test = [Actuation::Actuate_Device logic | logic <- logic_masked ]

    test_fail = rts.core.self_test_expect != (devices_test @ rts.core.self_test_dev)


Test_Instrumentation : [2] -> RTS -> RTS
Test_Instrumentation i rts = {rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test: ([8],[2][32],Channel) -> Bit
    Run_test (trip,vals,ch) = (rts.instr @ i)
                         >>>> Set_Maintenance True
                         >>>> Set_Mode ch Operate
                         >>>> Set_Setpoint ch 10
                         >>>> Set_Maintenance False
                         >>>> (\in -> Instrumentation::Step vals NoCommand in)
                         >>>> (\in -> (trip == (in.output_trip @ ch)))

    // For example...
    tests: [_]([8],[2][32],Channel)
    tests = [ (1, [h,l], T) | h <- high, l <- low ] #
            [ (0, [l,h], T) | h <- high, l <- low ] #
            [ (1, [l,h], P) | h <- high, l <- low ] #
            [ (0, [h,l], P) | h <- high, l <- low ] #
            [ (1, [t,p], S) | t <- [10,20,30], p <- [4,5,6] ] #
            [ (0, [t,p], S) | t <- [60,70,80], p <- [3,4,5] ]

    high: [_][32]
    high = [11, 12, 20]

    low: [_][32]
    low = [0, 9, 10]

Test_Voting: [1] -> RTS -> RTS
Test_Voting l rts = { rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test (on,d,trips) = (rts.act @ l)
                       >>>> Actuation::Set_Manual_Actuation d False
                       >>>> Actuation::Step trips
                       >>>> \a -> Is_Actuated d a == on

    tests : [_](Bit, [1], Actuation::Input)
    tests = [ (should_trip d [t0,t1,t2,t3], d, [t0,t1,t2,t3]) | d <- [0,1], t0 <- all_trips, t1 <- all_trips, t2 <- all_trips, t3 <- all_trips ]

    should_trip d ts =
      if d == D0 then
           (sum [ t @ T | t <- ts ] >= 2)
        || (sum [ t @ P | t <- ts ] >= 2)
      else
           sum [ t @ S | t <- ts ] >= 2

    all_trips: [8]Trips
    all_trips = [ [a,b,c] | a <- [0,1], b <- [0,1], c <- [0,1] ]

Test_Actuation: RTS -> RTS
Test_Actuation rts = { rts | error_detected = ~ (all Run_test tests)}
  where
    Run_test (on,votes) = on == Actuate_Device votes
    tests : [_](Bit, [2])
    tests = [ (v1 || v2, [v1, v2]) | v1 <- [0, 1], v2 <- [0, 1] ]

Update_UI: [4]Instrumentation -> [2]ActuationLogic -> CoreFSM -> CoreFSM
Update_UI instrs actuator rts0 =
  rts0 >>>> get_values >>>> get_bypass >>>> get_trip
  where
    get_values rts = {rts| ui = {rts.ui| instrumentation_values = [ Get_Reading i | i <- instrs ]}}
    get_bypass rts = {rts| ui = {rts.ui| instrumentation_bypass = [ [In_Mode T Bypass i, In_Mode P Bypass i, In_Mode S Bypass i] | i <- instrs ]}}
    get_trip   rts = {rts| ui = {rts.ui| instrumentation_trip = [ [Is_Tripped T i, Is_Tripped P i, Is_Tripped S i] | i <- instrs ]}}

Run_Event: Event -> RTS -> RTS
Run_Event e rts =
  if e.event == EVENT_MAINTENANCE then
    {rts| instr = update rts.instr (e.unit) (Set_Maintenance e.on_off (rts.instr @ e.unit))}
  else if (e.event == EVENT_TRIP_MODE) && (ch < `NChannels) && (e.mode < `NModes) then
    {rts| instr = update rts.instr (e.unit) (Set_Mode ch e.mode (rts.instr @ e.unit))}
  else if (e.event == EVENT_SETPOINT) && (ch < `NChannels) then
    {rts| instr = update rts.instr (e.unit) (Set_Setpoint ch e.setpoint (rts.instr @ e.unit))}
  else if (e.event == EVENT_ACTUATE) then
    {rts| act = [Set_Manual_Actuation dev e.on_off a | a <- rts.act]}
  else rts
  where
    ch : Channel
    ch = e.ch
    dev : Device
    dev = e.dev

private
    I : ([4]Instrumentation -> [4]Instrumentation) -> RTS -> RTS
    I f rts = {rts|instr = f rts.instr}
    A : ([2]ActuationLogic -> [2]ActuationLogic) -> RTS -> RTS
    A f rts = {rts|act = f rts.act}
    C : (CoreFSM -> CoreFSM) -> RTS -> RTS
    C f rts = {rts|core = f rts.core}


    /** @requirements
          CORE_UI_INSTRUMENTATION
    */
    property core_ui_instrumentation (rts: RTS) (i: [2]) =
           ((core'.ui.instrumentation_values @ i)     == Get_Reading (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ T) == In_Mode T Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ P) == In_Mode P Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_bypass @ i @ S) == In_Mode S Bypass (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ T)   == Is_Tripped T (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ P)   == Is_Tripped P (rts.instr @ i))
        /\ ((core'.ui.instrumentation_trip @ i @ S)   == Is_Tripped S (rts.instr @ i))
      where
        core' = Update_UI rts.instr rts.act rts.core

    property sense_to_actuate_0 rts (sensors : [4][2][32]) cmds =
        ~rts.core.self_test ==> (
           sum [ if Is_Tripped T i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ sum [ if Is_Tripped P i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated D0 a | a <- rts.act ]
        \/ or [ Is_Actuated D0 a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated D0 a | a <- rts'.act ]
      )
      where
        rts' = rts >>>> Sense_Actuate sensors cmds

    property sense_to_actuate_1 rts (sensors : [4][2][32]) cmds =
        ~rts.core.self_test ==> (
           sum [ if Is_Tripped S i then 1 else 0 | i <- rts'.instr ] >= 2
        \/ or [ Is_ManualActuated D1 a | a <- rts.act ]
        \/ or [ Is_Actuated D1 a | a <- rts.act ]
        /* --------------------- */ ==
        or [ Is_Actuated D1 a | a <- rts'.act ]
        )
      where
        rts' = rts >>>> Sense_Actuate sensors cmds

    property end_to_end_test rts i1 i2 (ch : [2]) vote sensors =
       (~rts.error_detected && (i1 != i2) && and [ (a.manual_actuate == 0) && (a.vote_actuate == 0) | a <- rts.act ] && (ch < 3)) ==> (
         ~rts'.error_detected
       )
     where
       rts' = RunEndToEnd rts i1 i2 ch vote sensors

    RunEndToEnd rts i1 i2 ch vote sensors = rts'
      where
       core0 = {rts.core| self_test = True,
                          self_test_instrs = [i1, i2],
                          self_test_channel = ch,
                          self_test_vote = vote,
                          self_test_dev = dev,
                          self_test_expect = expect }
       expect = if (ch == T) || (ch == P) then
                  and [ (instr.setpoints @ ch) < (vs @ ch) | vs <- sensors @@ [i1,i2] | instr <- rts.instr @@ [i1,i2] ]
                else
                  and [ (instr.setpoints @ ch) > Saturation (vs @ T) (vs @ P) | vs <- sensors @@ [i1,i2] | instr <- rts.instr @@ [i1,i2] ]
       dev = if (ch == T) || (ch == P) then D0 else D1
       rts' = {rts | core = core0 }
         >>>> I (\instrs -> [ if (i == i1) || (i == i2) then Set_Maintenance True instr else instr | instr <- instrs | i <- [0..3] ])
         >>>> I (\instrs -> [ if (i == i1) || (i == i2) then Set_Mode ch Operate instr else instr | instr <- instrs | i <- [0..3] ])
         >>>> Sense_Actuate sensors cmds
       cmds = repeat NoCommand

    property Test_Instrumentation_OK i rts =
      ~(rts.error_detected) ==>
      ~ ((Test_Instrumentation i rts).error_detected)

    property Test_Voting_OK l rts =
      (~rts.error_detected && and [ a.vote_actuate == 0 | a <- rts.act ]) ==>
      ~ ((Test_Voting l rts).error_detected)

    property Test_Actuation_OK rts =
      ~ (rts.error_detected) ==>
      ~ ((Test_Actuation rts).error_detected)
