//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eb)
//
// On Tue Dec  7 20:03:42 EST 2021
//
//
// Ports:
// Name                         I/O  size props
// leds                           O    32 reg
// RDY_leds                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkNervSoC(CLK,
		 RST_N,

		 leds,
		 RDY_leds);
  input  CLK;
  input  RST_N;

  // value method leds
  output [31 : 0] leds;
  output RDY_leds;

  // signals for module outputs
  wire [31 : 0] leds;
  wire RDY_leds;

  // register rg_dmem_rdata
  reg [31 : 0] rg_dmem_rdata;
  wire [31 : 0] rg_dmem_rdata$D_IN;
  wire rg_dmem_rdata$EN;

  // register rg_leds
  reg [31 : 0] rg_leds;
  wire [31 : 0] rg_leds$D_IN;
  wire rg_leds$EN;

  // ports of submodule dmem
  wire [31 : 0] dmem$D_IN, dmem$D_OUT_1;
  wire [29 : 0] dmem$ADDR_1,
		dmem$ADDR_2,
		dmem$ADDR_3,
		dmem$ADDR_4,
		dmem$ADDR_5,
		dmem$ADDR_IN;
  wire dmem$WE;

  // ports of submodule imem
  wire [31 : 0] imem$D_IN, imem$D_OUT_1;
  wire [29 : 0] imem$ADDR_1,
		imem$ADDR_2,
		imem$ADDR_3,
		imem$ADDR_4,
		imem$ADDR_5,
		imem$ADDR_IN;
  wire imem$WE;

  // ports of submodule nerv
  wire [35 : 0] nerv$m_get_dmem;
  wire [31 : 0] nerv$m_dmem_addr,
		nerv$m_dmem_rdata_xd,
		nerv$m_imem_addr,
		nerv$m_imem_data_xi;
  wire nerv$RDY_m_dmem_addr, nerv$RDY_m_get_dmem, nerv$m_stall_b;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_always,
       CAN_FIRE_RL_rl_memop,
       WILL_FIRE_RL_rl_always,
       WILL_FIRE_RL_rl_memop;

  // remaining internal signals
  wire [31 : 0] mask__h593, x__h656, x__h816, y__h657, y__h818;
  wire [7 : 0] SEXT_nerv_m_get_dmem__1_BIT_33_8___d19,
	       SEXT_nerv_m_get_dmem__1_BIT_34_5___d16,
	       SEXT_nerv_m_get_dmem__1_BIT_35_2___d13;

  // value method leds
  assign leds = rg_leds ;
  assign RDY_leds = 1'd1 ;

  // submodule dmem
  RegFile #(.addr_width(32'd30),
	    .data_width(32'd32),
	    .lo(30'h0),
	    .hi(30'd1073741823)) dmem(.CLK(CLK),
				      .ADDR_1(dmem$ADDR_1),
				      .ADDR_2(dmem$ADDR_2),
				      .ADDR_3(dmem$ADDR_3),
				      .ADDR_4(dmem$ADDR_4),
				      .ADDR_5(dmem$ADDR_5),
				      .ADDR_IN(dmem$ADDR_IN),
				      .D_IN(dmem$D_IN),
				      .WE(dmem$WE),
				      .D_OUT_1(dmem$D_OUT_1),
				      .D_OUT_2(),
				      .D_OUT_3(),
				      .D_OUT_4(),
				      .D_OUT_5());

  // submodule imem
  RegFileLoad #(.file("imem_contents.memhex32"),
		.addr_width(32'd30),
		.data_width(32'd32),
		.lo(30'h0),
		.hi(30'd1073741823),
		.binary(1'd0)) imem(.CLK(CLK),
				    .ADDR_1(imem$ADDR_1),
				    .ADDR_2(imem$ADDR_2),
				    .ADDR_3(imem$ADDR_3),
				    .ADDR_4(imem$ADDR_4),
				    .ADDR_5(imem$ADDR_5),
				    .ADDR_IN(imem$ADDR_IN),
				    .D_IN(imem$D_IN),
				    .WE(imem$WE),
				    .D_OUT_1(imem$D_OUT_1),
				    .D_OUT_2(),
				    .D_OUT_3(),
				    .D_OUT_4(),
				    .D_OUT_5());

  // submodule nerv
  mkNerv nerv(.CLK(CLK),
	      .RST_N(RST_N),
	      .m_dmem_rdata_xd(nerv$m_dmem_rdata_xd),
	      .m_imem_data_xi(nerv$m_imem_data_xi),
	      .m_stall_b(nerv$m_stall_b),
	      .m_trap(),
	      .m_imem_addr(nerv$m_imem_addr),
	      .m_dmem_addr(nerv$m_dmem_addr),
	      .RDY_m_dmem_addr(nerv$RDY_m_dmem_addr),
	      .m_get_dmem(nerv$m_get_dmem),
	      .RDY_m_get_dmem(nerv$RDY_m_get_dmem));

  // rule RL_rl_always
  assign CAN_FIRE_RL_rl_always = 1'd1 ;
  assign WILL_FIRE_RL_rl_always = 1'd1 ;

  // rule RL_rl_memop
  assign CAN_FIRE_RL_rl_memop = nerv$RDY_m_dmem_addr && nerv$RDY_m_get_dmem ;
  assign WILL_FIRE_RL_rl_memop = CAN_FIRE_RL_rl_memop ;

  // register rg_dmem_rdata
  assign rg_dmem_rdata$D_IN = dmem$D_OUT_1 ;
  assign rg_dmem_rdata$EN = CAN_FIRE_RL_rl_memop ;

  // register rg_leds
  assign rg_leds$D_IN = x__h656 | y__h657 ;
  assign rg_leds$EN =
	     WILL_FIRE_RL_rl_memop && nerv$m_dmem_addr == 32'h01000000 ;

  // submodule dmem
  assign dmem$ADDR_1 = nerv$m_dmem_addr[31:2] ;
  assign dmem$ADDR_2 = 30'h0 ;
  assign dmem$ADDR_3 = 30'h0 ;
  assign dmem$ADDR_4 = 30'h0 ;
  assign dmem$ADDR_5 = 30'h0 ;
  assign dmem$ADDR_IN = nerv$m_dmem_addr[31:2] ;
  assign dmem$D_IN = x__h816 | y__h657 ;
  assign dmem$WE = WILL_FIRE_RL_rl_memop && nerv$m_dmem_addr != 32'h01000000 ;

  // submodule imem
  assign imem$ADDR_1 = nerv$m_imem_addr[31:2] ;
  assign imem$ADDR_2 = 30'h0 ;
  assign imem$ADDR_3 = 30'h0 ;
  assign imem$ADDR_4 = 30'h0 ;
  assign imem$ADDR_5 = 30'h0 ;
  assign imem$ADDR_IN = 30'h0 ;
  assign imem$D_IN = 32'h0 ;
  assign imem$WE = 1'b0 ;

  // submodule nerv
  assign nerv$m_dmem_rdata_xd = rg_dmem_rdata ;
  assign nerv$m_imem_data_xi = imem$D_OUT_1 ;
  assign nerv$m_stall_b = 1'd0 ;

  // remaining internal signals
  assign SEXT_nerv_m_get_dmem__1_BIT_33_8___d19 = {8{nerv$m_get_dmem[33]}} ;
  assign SEXT_nerv_m_get_dmem__1_BIT_34_5___d16 = {8{nerv$m_get_dmem[34]}} ;
  assign SEXT_nerv_m_get_dmem__1_BIT_35_2___d13 = {8{nerv$m_get_dmem[35]}} ;
  assign mask__h593 =
	     { SEXT_nerv_m_get_dmem__1_BIT_35_2___d13,
	       SEXT_nerv_m_get_dmem__1_BIT_34_5___d16,
	       SEXT_nerv_m_get_dmem__1_BIT_33_8___d19,
	       SEXT_nerv_m_get_dmem__1_BIT_35_2___d13 } ;
  assign x__h656 = rg_leds & y__h818 ;
  assign x__h816 = dmem$D_OUT_1 & y__h818 ;
  assign y__h657 = nerv$m_get_dmem[31:0] & mask__h593 ;
  assign y__h818 =
	     { ~SEXT_nerv_m_get_dmem__1_BIT_35_2___d13,
	       ~SEXT_nerv_m_get_dmem__1_BIT_34_5___d16,
	       ~SEXT_nerv_m_get_dmem__1_BIT_33_8___d19,
	       ~SEXT_nerv_m_get_dmem__1_BIT_35_2___d13 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (rg_dmem_rdata$EN)
      rg_dmem_rdata <= `BSV_ASSIGNMENT_DELAY rg_dmem_rdata$D_IN;
    if (rg_leds$EN) rg_leds <= `BSV_ASSIGNMENT_DELAY rg_leds$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_dmem_rdata = 32'hAAAAAAAA;
    rg_leds = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkNervSoC

