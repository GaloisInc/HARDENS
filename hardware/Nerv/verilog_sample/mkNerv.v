//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eb)
//
// On Tue Dec  7 20:03:42 EST 2021
//
//
// Ports:
// Name                         I/O  size props
// m_trap                         O     1
// m_imem_addr                    O    32
// m_dmem_addr                    O    32
// RDY_m_dmem_addr                O     1
// m_get_dmem                     O    36
// RDY_m_get_dmem                 O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// m_stall_b                      I     1
// m_imem_data_xi                 I    32
// m_dmem_rdata_xd                I    32
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkNerv(CLK,
	      RST_N,

	      m_stall_b,

	      m_trap,

	      m_imem_addr,

	      m_imem_data_xi,

	      m_dmem_addr,
	      RDY_m_dmem_addr,

	      m_get_dmem,
	      RDY_m_get_dmem,

	      m_dmem_rdata_xd);
  input  CLK;
  input  RST_N;

  // action method m_stall
  input  m_stall_b;

  // value method m_trap
  output m_trap;

  // value method m_imem_addr
  output [31 : 0] m_imem_addr;

  // action method m_imem_data
  input  [31 : 0] m_imem_data_xi;

  // value method m_dmem_addr
  output [31 : 0] m_dmem_addr;
  output RDY_m_dmem_addr;

  // value method m_get_dmem
  output [35 : 0] m_get_dmem;
  output RDY_m_get_dmem;

  // action method m_dmem_rdata
  input  [31 : 0] m_dmem_rdata_xd;

  // signals for module outputs
  wire [35 : 0] m_get_dmem;
  wire [31 : 0] m_dmem_addr, m_imem_addr;
  wire RDY_m_dmem_addr, RDY_m_get_dmem, m_trap;

  // ports of submodule nerv_BVI
  wire [31 : 0] nerv_BVI$dmem_addr,
		nerv_BVI$dmem_rdata,
		nerv_BVI$dmem_wdata,
		nerv_BVI$imem_addr,
		nerv_BVI$imem_data;
  wire [3 : 0] nerv_BVI$dmem_wstrb;
  wire nerv_BVI$dmem_valid, nerv_BVI$stall, nerv_BVI$trap;

  // rule scheduling signals
  wire CAN_FIRE_m_dmem_rdata,
       CAN_FIRE_m_imem_data,
       CAN_FIRE_m_stall,
       WILL_FIRE_m_dmem_rdata,
       WILL_FIRE_m_imem_data,
       WILL_FIRE_m_stall;

  // action method m_stall
  assign CAN_FIRE_m_stall = 1'd1 ;
  assign WILL_FIRE_m_stall = 1'd1 ;

  // value method m_trap
  assign m_trap = nerv_BVI$trap ;

  // value method m_imem_addr
  assign m_imem_addr = nerv_BVI$imem_addr ;

  // action method m_imem_data
  assign CAN_FIRE_m_imem_data = 1'd1 ;
  assign WILL_FIRE_m_imem_data = 1'd1 ;

  // value method m_dmem_addr
  assign m_dmem_addr = nerv_BVI$dmem_addr ;
  assign RDY_m_dmem_addr = nerv_BVI$dmem_valid ;

  // value method m_get_dmem
  assign m_get_dmem = { nerv_BVI$dmem_wstrb, nerv_BVI$dmem_wdata } ;
  assign RDY_m_get_dmem = nerv_BVI$dmem_valid ;

  // action method m_dmem_rdata
  assign CAN_FIRE_m_dmem_rdata = 1'd1 ;
  assign WILL_FIRE_m_dmem_rdata = 1'd1 ;

  // submodule nerv_BVI
  nerv nerv_BVI(.clock(CLK),
		.reset(RST_N),
		.dmem_rdata(nerv_BVI$dmem_rdata),
		.imem_data(nerv_BVI$imem_data),
		.stall(nerv_BVI$stall),
		.trap(nerv_BVI$trap),
		.imem_addr(nerv_BVI$imem_addr),
		.dmem_valid(nerv_BVI$dmem_valid),
		.dmem_addr(nerv_BVI$dmem_addr),
		.dmem_wstrb(nerv_BVI$dmem_wstrb),
		.dmem_wdata(nerv_BVI$dmem_wdata));

  // submodule nerv_BVI
  assign nerv_BVI$dmem_rdata = m_dmem_rdata_xd ;
  assign nerv_BVI$imem_data = m_imem_data_xi ;
  assign nerv_BVI$stall = m_stall_b ;
endmodule  // mkNerv

