print "Loading reference term";
instr_reference <- cryptol_load "../../models/RTS/Instrumentation.cry";

print "Loading generated term";
generated      <- llvm_load_module "step_trip_signals.bc";

// The byte types below (llvm_int 8; [8]) are due to
// https://github.com/GaloisInc/crucible/issues/934
let spec = do {
  // inp: [4][3]
  inp   <- llvm_fresh_expanded_val (llvm_array 2 (llvm_int 32));
  p_inp <- llvm_alloc (llvm_array 2 (llvm_int 32));
  llvm_points_to p_inp inp;

  let instr_ty = llvm_struct_type [llvm_array 3 (llvm_int 32),
                                   llvm_array 3 (llvm_int 32),
                                   llvm_int 8,
                                   llvm_int 8,
                                   llvm_int 8,
                                   llvm_int 8];

  instr       <- llvm_fresh_expanded_val instr_ty;
  instr_out   <- llvm_fresh_expanded_val instr_ty;
  p_state     <- llvm_alloc instr_ty;
  p_state_out <- llvm_alloc instr_ty;
  llvm_points_to p_state instr;
  llvm_points_to p_state_out instr_out;

  llvm_execute_func [p_state_out, p_inp, p_state];


//  let ref_out = llvm_term {{ instr_reference::Step_Trip_Signals
//                            inp
//                            {instr| bypass = drop (instr.bypass),
//                                    manual_trip = drop (instr.manual_trip),
//                                    sensor_trip = drop (instr.sensor_trip),
//                                    maintenance = drop (instr.maintenance)} }};

  // vote_step : [4][3] -> [2]
  // Cryptol is big endian
  // But we're sticking with the standard bit 0 is the LSB in the C code
//  llvm_postcond {{ True }};
};

llvm_verify generated "Step_Trip_Signals" [] false spec z3;
