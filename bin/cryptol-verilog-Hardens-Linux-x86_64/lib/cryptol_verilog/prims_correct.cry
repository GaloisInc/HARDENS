module cryptol_verilog::prims_correct where

/* This module duplicates the definitions in SuiteB with the exception
   of replacing cryptol primitives with the definitions in
   cryptol_verilog::*_prims. 

   The purpose of the duplication is to define properties that
   establish equivalence with the standard SuiteB definitions
*/

import SuiteB as SuiteB

import cryptol_verilog::cryptol_prims as CPrims
import cryptol_verilog::aes_prims as AESPrims
import cryptol_verilog::sha256_prims as SHA256Prims
import cryptol_verilog::sha512_prims as SHA512Prims

property pmod_correct_1 (x : [4]) (y : [4]) =
  y != 0 ==> CPrims::pmod x y == pmod x y

property pmod_correct_2 (x : [8]) (y : [4]) =
  y != 0 ==> CPrims::pmod x y == pmod x y

property pmod_correct_3 (x : [4]) (y : [11]) =
  y != 0 ==> CPrims::pmod x y == pmod x y

/***** AES *****/

aes128EncryptSchedule : [128] -> SuiteB::AESEncryptKeySchedule SuiteB::AES128
aes128EncryptSchedule = aesExpandEncryptSchedule

property aes128EncryptSchedule_correct (txt : [128]) =
  SuiteB::aes128EncryptSchedule txt == aes128EncryptSchedule txt

aes128DecryptSchedule : [128] -> SuiteB::AESDecryptKeySchedule SuiteB::AES128
aes128DecryptSchedule = aesExpandDecryptSchedule

property aes128DecryptSchedule_correct (txt : [128]) =
  SuiteB::aes128DecryptSchedule txt == aes128DecryptSchedule txt

aes128Schedules : [128] -> (SuiteB::AESEncryptKeySchedule SuiteB::AES128, SuiteB::AESDecryptKeySchedule SuiteB::AES128)
aes128Schedules = aesExpandSchedules

property aes128Schedules_correct (txt : [128]) =
  SuiteB::aes128Schedules txt == aes128Schedules txt

aes192EncryptSchedule : [192] -> SuiteB::AESEncryptKeySchedule SuiteB::AES192
aes192EncryptSchedule = aesExpandEncryptSchedule

property aes192EncryptSchedule_correct (txt : [192]) =
  SuiteB::aes192EncryptSchedule txt == aes192EncryptSchedule txt

aes192DecryptSchedule : [192] -> SuiteB::AESDecryptKeySchedule SuiteB::AES192
aes192DecryptSchedule = aesExpandDecryptSchedule

property aes192DecryptSchedule_correct (txt : [192]) =
  SuiteB::aes192DecryptSchedule txt == aes192DecryptSchedule txt

aes192Schedules : [192] -> (SuiteB::AESEncryptKeySchedule SuiteB::AES192, SuiteB::AESDecryptKeySchedule SuiteB::AES192)
aes192Schedules = aesExpandSchedules

property aes192Schedules_correct (txt : [192]) =
  SuiteB::aes192Schedules txt == aes192Schedules txt

aes256EncryptSchedule : [256] -> SuiteB::AESEncryptKeySchedule SuiteB::AES256
aes256EncryptSchedule = aesExpandEncryptSchedule

property aes256EncryptSchedule_correct (txt : [256]) =
  SuiteB::aes256EncryptSchedule txt == aes256EncryptSchedule txt

aes256DecryptSchedule: [256] -> SuiteB::AESDecryptKeySchedule SuiteB::AES256
aes256DecryptSchedule = aesExpandDecryptSchedule

property aes256DecryptSchedule_correct (txt : [256]) =
  SuiteB::aes256DecryptSchedule txt == aes256DecryptSchedule txt

aes256Schedules : [256] -> (SuiteB::AESEncryptKeySchedule SuiteB::AES256, SuiteB::AESDecryptKeySchedule SuiteB::AES256)
aes256Schedules = aesExpandSchedules

property aes256Schedules_correct (txt : [256]) =
  SuiteB::aes256Schedules txt == aes256Schedules txt

aesEncryptBlock : {k} (fin k) => SuiteB::AESEncryptKeySchedule k -> [128] -> [128]
aesEncryptBlock schedule plaintext = rnf (join final)
  where
  final = (AESPrims::EncFinalRound (rds!0)) ^ schedule.aesEncFinalKey

  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #
        [ AESPrims::EncRound r ^ rdk
        | rdk <- schedule.aesEncRoundKeys
        | r   <- rds
        ]

property aesEncryptBlock_correct_4 (sched : SuiteB::AESEncryptKeySchedule 4) txt =
  SuiteB::aesEncryptBlock sched txt == aesEncryptBlock sched txt

property aesEncryptBlock_correct_7 (sched : SuiteB::AESEncryptKeySchedule 7) txt =
  SuiteB::aesEncryptBlock sched txt == aesEncryptBlock sched txt

property aesEncryptBlock_correct_8 (sched : SuiteB::AESEncryptKeySchedule 8) txt =
  SuiteB::aesEncryptBlock sched txt == aesEncryptBlock sched txt

aesDecryptBlock : {k} (fin k) => SuiteB::AESDecryptKeySchedule k -> [128] -> [128]
aesDecryptBlock schedule cyphertext = rnf (join final)
  where
  final = (AESPrims::DecFinalRound (rds!0)) ^ schedule.aesDecFinalKey

  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #
        [ AESPrims::DecRound r ^ rdk
        | rdk <- schedule.aesDecRoundKeys
        | r   <- rds
        ]

property aesDecryptBlock_correct_4 (sched : SuiteB::AESDecryptKeySchedule 4) txt =
  SuiteB::aesDecryptBlock sched txt == aesDecryptBlock sched txt

property aesDecryptBlock_correct_7 (sched : SuiteB::AESDecryptKeySchedule 7) txt =
  SuiteB::aesDecryptBlock sched txt == aesDecryptBlock sched txt

property aesDecryptBlock_correct_8 (sched : SuiteB::AESDecryptKeySchedule 8) txt =
  SuiteB::aesDecryptBlock sched txt == aesDecryptBlock sched txt

/* SHA 256 Properties */

private
    // Duplicated from SuiteB.cry:

    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> SuiteB::AESEncryptKeySchedule k
    aesExpandEncryptSchedule key = rnf
         { aesEncInitialKey = ks @  0
         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]
         , aesEncFinalKey   = ks @  `(k+6)
         }
      where
      ks : [k+7]SuiteB::AESRoundKey
      ks = groupBy`{4} (AESPrims::KeyExpand`{k} (split key))

    aesEncToDecSchedule : {k} (fin k) => SuiteB::AESEncryptKeySchedule k -> SuiteB::AESDecryptKeySchedule k
    aesEncToDecSchedule enc = rnf
       { aesDecInitialKey = enc.aesEncFinalKey
       , aesDecRoundKeys  = map AESPrims::InvMixColumns (reverse (enc.aesEncRoundKeys))
       , aesDecFinalKey   = enc.aesEncInitialKey
       }

    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> SuiteB::AESDecryptKeySchedule k
    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)

    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (SuiteB::AESEncryptKeySchedule k, SuiteB::AESDecryptKeySchedule k)
    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)
      where encS = aesExpandEncryptSchedule key

/***** SHA2 *****/

sha224 : {L} (fin L) => [L] -> [224]
sha224 msg = join (SHA256Prims::processSHA2_224 (sha2blocks`{32} msg))

property sha224_correct_1 (msg : [10]) =
  SuiteB::sha224 msg == sha224 msg
property sha224_correct_2 (msg : [100]) =
  SuiteB::sha224 msg == sha224 msg
property sha224_correct_3 (msg : [224]) =
  SuiteB::sha224 msg == sha224 msg
property sha224_correct_4 (msg : [1000]) =
  SuiteB::sha224 msg == sha224 msg

sha256 : {L} (fin L) => [L] -> [256]
sha256 msg = join (SHA256Prims::processSHA2_256 (sha2blocks`{32} msg))

property sha256_correct_1 (msg : [10]) =
  SuiteB::sha256 msg == sha256 msg
property sha256_correct_2 (msg : [100]) =
  SuiteB::sha256 msg == sha256 msg
property sha256_correct_3 (msg : [256]) =
  SuiteB::sha256 msg == sha256 msg
property sha256_correct_4 (msg : [1000]) =
  SuiteB::sha256 msg == sha256 msg

sha384 : {L} (fin L) => [L] -> [384]
sha384 msg = join (SHA512Prims::processSHA2_384 (sha2blocks`{64} msg))

property sha384_correct_1 (msg : [10]) =
  SuiteB::sha384 msg == sha384 msg
property sha384_correct_2 (msg : [100]) =
  SuiteB::sha384 msg == sha384 msg
property sha384_correct_3 (msg : [384]) =
  SuiteB::sha384 msg == sha384 msg
property sha384_correct_4 (msg : [1000]) =
  SuiteB::sha384 msg == sha384 msg

sha512 : {L} (fin L) => [L] -> [512]
sha512 msg = join (SHA512Prims::processSHA2_512 (sha2blocks`{64} msg))

property sha512_correct_1 (msg : [10]) =
  SuiteB::sha512 msg == sha512 msg
property sha512_correct_2 (msg : [100]) =
  SuiteB::sha512 msg == sha512 msg
property sha512_correct_3 (msg : [512]) =
  SuiteB::sha512 msg == sha512 msg
property sha512_correct_4 (msg : [1000]) =
  SuiteB::sha512 msg == sha512 msg

private
    type sha2_block_size w = 16 * w
    type sha2_num_blocks w L = (L+1+2*w) /^ sha2_block_size w
    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w

    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]
    sha2pad M = M # 0b1 # zero # ((fromInteger `L) : [2*w])

    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>
      [L] -> [sha2_num_blocks w L][16][w]
    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]