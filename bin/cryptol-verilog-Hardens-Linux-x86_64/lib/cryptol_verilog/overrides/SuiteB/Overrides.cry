module SuiteB::Overrides where

import cryptol_verilog::aes_prims as AESPrims
import cryptol_verilog::sha256_prims as SHA256Prims
import cryptol_verilog::sha512_prims as SHA512Prims

import SuiteB

aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k
aesExpandEncryptSchedule key = rnf
     { aesEncInitialKey = ks @  0
     , aesEncRoundKeys  = ks @@ ([ 1 .. k+5 ] : [k+5][width (k+7)])
     , aesEncFinalKey   = ks @  `(k+6)
     }
  where
  ks : [k+7]AESRoundKey
  ks = groupBy`{4} (AESKeyExpand`{k} (split key))

AESEncRound : [4][32] -> [4][32]
AESEncRound = AESPrims::EncRound

AESEncFinalRound : [4][32] -> [4][32]
AESEncFinalRound = AESPrims::EncFinalRound

AESDecRound      : [4][32] -> [4][32]
AESDecRound = AESPrims::DecRound

AESDecFinalRound : [4][32] -> [4][32]
AESDecFinalRound = AESPrims::DecFinalRound

AESInvMixColumns : [4][32] -> [4][32]
AESInvMixColumns = AESPrims::InvMixColumns

AESKeyExpand : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]
AESKeyExpand = AESPrims::KeyExpand

/***** SHA2 *****/

type sha2_block_size w = 16 * w
type sha2_num_blocks w L = (L+1+2*w) /^ (sha2_block_size w)
type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w

sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]
sha2pad M = M # 0b1 # zero # ((fromInteger `L) : [2*w])

sha2blocks : {w, L} (fin w, fin L, w >= 1) =>
  [L] -> [sha2_num_blocks w L][16][w]
sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]

/**
 * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,
 * which are assumed to already be correctly padded.
 */
processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]
processSHA2_224 = SHA256Prims::processSHA2_224

/**
 * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,
 * which are assumed to already be correctly padded.
 */
processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]
processSHA2_256 = SHA256Prims::processSHA2_256

/**
 * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,
 * which are assumed to already be correctly padded.
 */
processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]
processSHA2_384 = SHA512Prims::processSHA2_384

/**
 * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,
 * which are assumed to already be correctly padded.
 */
processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]
processSHA2_512 = SHA512Prims::processSHA2_512